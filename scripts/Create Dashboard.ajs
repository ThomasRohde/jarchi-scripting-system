/**
 * @name Create Dashboard
 * @description Creates a new dashboard view with all available chart templates
 * arranged in a symmetric 4x3 grid layout. Initializes missing data properties
 * with random values on matching elements and renders all charts.
 * @version 1.0.0
 * @lastModifiedDate 2026-02-15
 */

console.clear();
console.show();

load(__DIR__ + "lib/log.js");
load(__DIR__ + "lib/requireModel.js");
load(__DIR__ + "lib/chartDefinitions.js");
load(__DIR__ + "lib/chartDataCollectors.js");
load(__DIR__ + "vendor/chartjs/chart-sync.js");

(function () {
    "use strict";

    var Files = Java.type("java.nio.file.Files");
    var JPath = Java.type("java.nio.file.Paths");
    var System = Java.type("java.lang.System");
    var IEditorModelManager = Java.type("com.archimatetool.editor.model.IEditorModelManager");
    var ArchimateModelUtils = Java.type("com.archimatetool.model.util.ArchimateModelUtils");
    var IArchiveManager = Java.type("com.archimatetool.editor.model.IArchiveManager");

    // =========================================================================
    // Layout constants
    // =========================================================================

    var COLS = 4;
    var CHART_WIDTH = 500;
    var CHART_HEIGHT = 350;
    var COL_GAP = 30;
    var MARGIN_LEFT = 50;
    var TITLE_Y = 25;
    var TITLE_HEIGHT = 70;
    var SUBTITLE_HEIGHT = 28;
    var SECTION_HEADER_HEIGHT = 32;
    var DESC_HEIGHT = 28;
    var DESC_CHART_GAP = 4;
    var SECTION_GAP = 45;

    // =========================================================================
    // Dashboard sections — logical grouping with descriptions
    // =========================================================================

    var DASHBOARD_SECTIONS = [
        {
            title: "Overview",
            charts: [
                { id: "element-distribution", desc: "Composition of the architecture model by element type" },
                { id: "architecture-layer-balance", desc: "Distribution of elements across ArchiMate layers" },
                { id: "relationship-complexity", desc: "Elements with the highest number of dependencies" },
                { id: "view-coverage", desc: "Elements appearing on the most architecture views" }
            ]
        },
        {
            title: "Application Analysis",
            charts: [
                { id: "technical-debt-distribution", desc: "Technical debt classification across applications" },
                { id: "application-portfolio", desc: "Application landscape by business value, quality, and cost" },
                { id: "risk-assessment-matrix", desc: "Application risk exposure by impact and likelihood" },
                { id: "lifecycle-by-category", desc: "Application lifecycle stages by department" }
            ]
        },
        {
            title: "Technology & Capability",
            charts: [
                { id: "technology-lifecycle", desc: "Technology asset lifecycle status distribution" },
                { id: "technology-stack-composition", desc: "Technology stack categories by lifecycle stage" },
                { id: "capability-maturity", desc: "Current vs target maturity levels across capabilities" },
                { id: "maturity-trend", desc: "Capability maturity gap \u2014 current state vs target" }
            ]
        }
    ];

    // =========================================================================
    // Style constants
    // =========================================================================

    var COLOR_TITLE = "#1a1a2e";
    var COLOR_SUBTITLE = "#555555";
    var COLOR_SECTION = "#2c3e50";
    var COLOR_DESC = "#666666";

    // =========================================================================
    // Random value generators for each property
    // =========================================================================

    var RANDOM_GENERATORS = {
        "technical-debt": function () {
            var vals = ["low", "medium", "high", "critical"];
            return vals[Math.floor(Math.random() * vals.length)];
        },
        "lifecycle-status": function () {
            var vals = ["emerging", "current", "sunset", "retired"];
            return vals[Math.floor(Math.random() * vals.length)];
        },
        "business-value": function () {
            return String(Math.floor(Math.random() * 5) + 1);
        },
        "technical-quality": function () {
            return String(Math.floor(Math.random() * 5) + 1);
        },
        "annual-cost": function () {
            return String(Math.floor(Math.random() * 450) + 50);
        },
        "maturity-current": function () {
            return String(Math.floor(Math.random() * 4) + 1);
        },
        "maturity-target": function () {
            return String(Math.floor(Math.random() * 3) + 3);
        },
        "department": function () {
            var vals = ["IT", "Finance", "HR", "Operations", "Marketing"];
            return vals[Math.floor(Math.random() * vals.length)];
        },
        "risk-impact": function () {
            return String(Math.floor(Math.random() * 5) + 1);
        },
        "risk-likelihood": function () {
            return String(Math.floor(Math.random() * 5) + 1);
        },
        "technology-category": function () {
            var vals = ["Infrastructure", "Middleware", "Database", "Security", "DevOps"];
            return vals[Math.floor(Math.random() * vals.length)];
        }
    };

    // =========================================================================
    // Helpers
    // =========================================================================

    function getRawModel() {
        var models = IEditorModelManager.INSTANCE.getModels();
        if (models.size() === 1) return models.get(0);
        var modelName = model.name;
        for (var i = 0; i < models.size(); i++) {
            if (models.get(i).getName() === modelName) return models.get(i);
        }
        return models.get(0);
    }

    function setNoteImage(noteProxy, pngFilePath) {
        var rawModel = getRawModel();
        var rawNote = ArchimateModelUtils.getObjectByID(rawModel, noteProxy.id);
        if (!rawNote) throw new Error("Could not find raw EMF object for note: " + noteProxy.id);

        var archiveManager = rawModel.getAdapter(IArchiveManager.class);
        if (!archiveManager) throw new Error("Could not get IArchiveManager for model");

        var pngBytes = Files.readAllBytes(JPath.get(pngFilePath));
        var imagePath = archiveManager.addByteContentEntry(pngFilePath, pngBytes);

        rawNote.setImagePath(imagePath);
        rawNote.setImagePosition(9); // IIconic.IMAGE_POSITION_FILL
    }

    function getTempPath(noteId) {
        var tmpDir = System.getProperty("java.io.tmpdir");
        return JPath.get(tmpDir, "jarchi-chart-" + noteId + ".png").toString();
    }

    // BORDER.NONE constant for notes
    var BORDER_NONE = 2;

    // =========================================================================
    // Sample elements for types that may not exist in the model
    // =========================================================================

    var SAMPLE_ELEMENT_NAMES = {
        "capability": [
            "Data Management", "Customer Engagement", "Financial Planning",
            "Risk Management", "Supply Chain Management", "Human Capital Management",
            "Digital Innovation", "Regulatory Compliance"
        ]
    };

    /**
     * Ensure the model has named elements of each required type.
     * Creates sample elements by name (skipping any that already exist)
     * so that charts with skipGenericNames won't end up empty.
     */
    function ensureSampleElements(templates) {
        var typesChecked = {};
        var totalCreated = 0;

        for (var t = 0; t < templates.length; t++) {
            var tmpl = templates[t];
            if (!tmpl.propertiesCreated || tmpl.propertiesCreated.length === 0) continue;

            for (var p = 0; p < tmpl.propertiesCreated.length; p++) {
                var propDef = tmpl.propertiesCreated[p];
                for (var q = 0; q < propDef.targetTypes.length; q++) {
                    var elType = propDef.targetTypes[q];
                    if (typesChecked[elType]) continue;
                    typesChecked[elType] = true;

                    if (!SAMPLE_ELEMENT_NAMES[elType]) continue;

                    // Collect existing element names to avoid duplicates
                    var existingNames = {};
                    $(elType).each(function (el) {
                        existingNames[(el.name || "").trim()] = true;
                    });

                    var names = SAMPLE_ELEMENT_NAMES[elType];
                    var created = 0;
                    for (var n = 0; n < names.length; n++) {
                        if (!existingNames[names[n]]) {
                            model.createElement(elType, names[n]);
                            created++;
                        }
                    }

                    if (created > 0) {
                        totalCreated += created;
                        log.detail("  Created " + created + " sample " + elType + " element(s)");
                    }
                }
            }
        }

        return totalCreated;
    }

    /**
     * Initialize properties with random values on matching elements.
     * Only sets values where the property doesn't already exist.
     */
    function initializeRandomProperties(templates) {
        var totalInitialized = 0;
        var processedProps = {};

        for (var t = 0; t < templates.length; t++) {
            var tmpl = templates[t];
            if (!tmpl.propertiesCreated || tmpl.propertiesCreated.length === 0) continue;

            for (var p = 0; p < tmpl.propertiesCreated.length; p++) {
                var propDef = tmpl.propertiesCreated[p];
                var propKey = propDef.name + ":" + propDef.targetTypes.join(",");

                if (processedProps[propKey]) continue;
                processedProps[propKey] = true;

                var generator = RANDOM_GENERATORS[propDef.name];
                if (!generator) continue;

                // Build target collection ($() doesn't support comma-separated types)
                var targetCollection;
                if (propDef.targetTypes.length === 1) {
                    targetCollection = $(propDef.targetTypes[0]);
                } else {
                    targetCollection = $(propDef.targetTypes[0]);
                    for (var q = 1; q < propDef.targetTypes.length; q++) {
                        targetCollection = targetCollection.add($(propDef.targetTypes[q]));
                    }
                }

                var initialized = 0;
                targetCollection.each(function (el) {
                    if (el.prop(propDef.name) === null) {
                        el.prop(propDef.name, generator());
                        initialized++;
                    }
                });

                totalInitialized += initialized;
                if (initialized > 0) {
                    log.detail("  " + propDef.name + ": set on " + initialized + " element(s)");
                }
            }
        }

        return totalInitialized;
    }

    // =========================================================================
    // Main
    // =========================================================================

    try {
        requireModel();
        log.header("Create Dashboard");

        var dashboardName = window.prompt("Dashboard view name:", "EA Dashboard");
        if (!dashboardName) {
            log.warn("Cancelled by user.");
            return;
        }

        // Build template lookup
        var allTemplates = chartDefinitions.getAllTemplates();
        var templateMap = {};
        for (var t = 0; t < allTemplates.length; t++) {
            templateMap[allTemplates[t].id] = allTemplates[t];
        }

        // Collect all templates referenced by dashboard sections
        var orderedTemplates = [];
        for (var s = 0; s < DASHBOARD_SECTIONS.length; s++) {
            var charts = DASHBOARD_SECTIONS[s].charts;
            for (var c = 0; c < charts.length; c++) {
                var tmpl = templateMap[charts[c].id];
                if (tmpl) orderedTemplates.push(tmpl);
            }
        }

        if (orderedTemplates.length === 0) {
            log.error("No chart templates found.");
            return;
        }

        log.info("Creating dashboard with " + orderedTemplates.length + " charts...");

        // --- Create sample elements for types that don't exist ---
        var samplesCreated = ensureSampleElements(orderedTemplates);
        if (samplesCreated > 0) {
            log.info("Created " + samplesCreated + " sample element(s) for missing types.");
        }

        // --- Initialize missing properties with random values ---
        log.info("Initializing missing data properties with random values...");
        var totalInit = initializeRandomProperties(orderedTemplates);
        if (totalInit > 0) {
            log.info("Initialized " + totalInit + " property value(s) across model elements.");
        } else {
            log.detail("  All properties already set (or no matching elements).");
        }

        // --- Create the dashboard view ---
        var dashView = model.createArchimateView(dashboardName);
        log.info("Created view: " + dashboardName);

        var totalGridWidth = COLS * CHART_WIDTH + (COLS - 1) * COL_GAP;

        // --- Title ---
        var titleNote = dashView.createObject("note", MARGIN_LEFT, TITLE_Y, totalGridWidth, TITLE_HEIGHT);
        titleNote.setText(dashboardName);
        titleNote.borderType = BORDER_NONE;
        titleNote.fontStyle = "bold";
        titleNote.fontSize = 26;
        titleNote.fontColor = COLOR_TITLE;
        titleNote.textAlignment = TEXT_ALIGNMENT.CENTER;

        // --- Subtitle (model name + date) ---
        var today = new java.text.SimpleDateFormat("yyyy-MM-dd").format(new java.util.Date());
        var subtitleY = TITLE_Y + TITLE_HEIGHT;
        var subtitleNote = dashView.createObject("note", MARGIN_LEFT, subtitleY, totalGridWidth, SUBTITLE_HEIGHT);
        subtitleNote.setText("Model: " + (model.name || "unnamed") + "  \u2022  Generated: " + today);
        subtitleNote.borderType = BORDER_NONE;
        subtitleNote.fontSize = 11;
        subtitleNote.fontColor = COLOR_SUBTITLE;
        subtitleNote.textAlignment = TEXT_ALIGNMENT.CENTER;

        // --- Place sections, descriptions, and chart notes ---
        var chartNotes = [];
        var cursorY = subtitleY + SUBTITLE_HEIGHT + 20;

        for (var s = 0; s < DASHBOARD_SECTIONS.length; s++) {
            var section = DASHBOARD_SECTIONS[s];

            // Section header
            var sectionNote = dashView.createObject("note", MARGIN_LEFT, cursorY, totalGridWidth, SECTION_HEADER_HEIGHT);
            sectionNote.setText(section.title.toUpperCase());
            sectionNote.borderType = BORDER_NONE;
            sectionNote.fontStyle = "bold";
            sectionNote.fontSize = 13;
            sectionNote.fontColor = COLOR_SECTION;
            sectionNote.textAlignment = TEXT_ALIGNMENT.LEFT;
            sectionNote.textPosition = TEXT_POSITION.CENTER;
            cursorY += SECTION_HEADER_HEIGHT + 6;

            // Description notes (one per chart, side by side)
            for (var c = 0; c < section.charts.length; c++) {
                var chartDef = section.charts[c];
                var col = c % COLS;
                var x = MARGIN_LEFT + col * (CHART_WIDTH + COL_GAP);

                var descNote = dashView.createObject("note", x, cursorY, CHART_WIDTH, DESC_HEIGHT);
                descNote.setText(chartDef.desc);
                descNote.borderType = BORDER_NONE;
                descNote.fontSize = 12;
                descNote.fontStyle = "italic";
                descNote.fontColor = COLOR_DESC;
                descNote.textAlignment = TEXT_ALIGNMENT.CENTER;
                descNote.textPosition = TEXT_POSITION.CENTER;
            }
            cursorY += DESC_HEIGHT + DESC_CHART_GAP;

            // Chart notes
            for (var c = 0; c < section.charts.length; c++) {
                var chartDef = section.charts[c];
                var tmpl = templateMap[chartDef.id];
                if (!tmpl) continue;

                var col = c % COLS;
                var x = MARGIN_LEFT + col * (CHART_WIDTH + COL_GAP);

                var definition = chartDefinitions.createDefinition(tmpl.id, {
                    title: tmpl.chartConfig.title,
                    width: CHART_WIDTH,
                    height: CHART_HEIGHT,
                    scope: "model"
                });

                // Disable in-chart title — the description note above serves as the label
                if (definition.chartOptions && definition.chartOptions.plugins &&
                    definition.chartOptions.plugins.title) {
                    definition.chartOptions.plugins.title.display = false;
                }

                var noteObj = dashView.createObject("note", x, cursorY, CHART_WIDTH, CHART_HEIGHT);
                noteObj.setText(definition.title);
                noteObj.prop("chart-definition", JSON.stringify(definition));
                noteObj.borderType = BORDER_NONE;

                chartNotes.push({ note: noteObj, definition: definition });
                log.detail("  Placed: " + definition.title);
            }
            cursorY += CHART_HEIGHT + SECTION_GAP;
        }

        // --- Render all charts ---
        log.info("Rendering " + chartNotes.length + " chart(s)...");

        var rendered = 0;
        var failed = 0;

        for (var r = 0; r < chartNotes.length; r++) {
            var entry = chartNotes[r];
            var noteObj = entry.note;
            var definition = entry.definition;

            try {
                var data = chartDataCollectors.collectData(definition, dashView);

                var chartConfig = {
                    type: definition.type,
                    data: data,
                    options: definition.chartOptions || {},
                    backgroundColor: definition.backgroundColor || "#FFFFFF"
                };

                var outputPath = getTempPath(noteObj.id);
                chartSync.renderChart(chartConfig, definition.width, definition.height, outputPath);

                if (!Files.exists(JPath.get(outputPath))) {
                    throw new Error("PNG not created at: " + outputPath);
                }

                setNoteImage(noteObj, outputPath);
                noteObj.setText("");

                rendered++;
                log.detail("  Rendered: " + definition.title);
            } catch (err) {
                failed++;
                log.error("  Failed: " + definition.title + " \u2014 " + err.toString());
                if (err.stack) log.detail("    " + err.stack);
            }
        }

        // --- Open the dashboard view ---
        dashView.openInUI();

        // --- Summary ---
        var summary = "Dashboard '" + dashboardName + "' created with " +
            rendered + " chart(s) rendered";
        if (failed > 0) {
            summary += " (" + failed + " failed)";
            log.warn(summary);
        } else {
            log.success(summary);
        }

        log.success("Create Dashboard complete.");
    } catch (error) {
        log.error("Script failed: " + error.toString());
        if (error.stack) log.error(error.stack);
        window.alert("Error: " + error.message);
    }
})();
