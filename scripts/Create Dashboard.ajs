/**
 * @name Create Dashboard
 * @description Creates a new dashboard view with all available chart templates
 * arranged in a symmetric 4x3 grid layout. Initializes missing data properties
 * with random values on matching elements and renders all charts.
 * @version 1.0.0
 * @lastModifiedDate 2026-02-15
 */

console.clear();
console.show();

load(__DIR__ + "lib/log.js");
load(__DIR__ + "lib/requireModel.js");
load(__DIR__ + "lib/chartDefinitions.js");
load(__DIR__ + "lib/chartDataCollectors.js");
load(__DIR__ + "vendor/chartjs/chart-sync.js");

(function () {
    "use strict";

    var Files = Java.type("java.nio.file.Files");
    var JPath = Java.type("java.nio.file.Paths");
    var System = Java.type("java.lang.System");
    var IEditorModelManager = Java.type("com.archimatetool.editor.model.IEditorModelManager");
    var ArchimateModelUtils = Java.type("com.archimatetool.model.util.ArchimateModelUtils");
    var IArchiveManager = Java.type("com.archimatetool.editor.model.IArchiveManager");

    // =========================================================================
    // Layout constants
    // =========================================================================

    var COLS = 4;
    var CHART_WIDTH = 480;
    var CHART_HEIGHT = 320;
    var COL_GAP = 20;
    var ROW_GAP = 60;
    var MARGIN_LEFT = 20;
    var TOTAL_WIDTH = (COLS * CHART_WIDTH) + ((COLS - 1) * COL_GAP) + (2 * MARGIN_LEFT); // Calculated total width
    
    // Y Positions calculated dynamically, but starting offsets:
    var TITLE_Y = 20;
    var TITLE_HEIGHT = 50;
    var SUBTITLE_HEIGHT = 30;
    var KPI_HEIGHT = 100; // New KPI section
    var SECTION_HEADER_HEIGHT = 40;
    var SECTION_PADDING = 20;
    var INNER_PAD = 10; // Inset for children inside bordered groups so they don't cover borders

    // =========================================================================
    // Dashboard sections — logical grouping with descriptions
    // =========================================================================

    var DASHBOARD_SECTIONS = [
        {
            title: "Overview",
            charts: [
                { id: "element-distribution", desc: "Composition of the architecture model by element type" },
                { id: "architecture-layer-balance", desc: "Distribution of elements across ArchiMate layers" },
                { id: "relationship-complexity", desc: "Elements with the highest number of dependencies" },
                { id: "view-coverage", desc: "Elements appearing on the most architecture views" }
            ]
        },
        {
            title: "Application Analysis",
            charts: [
                { id: "technical-debt-distribution", desc: "Technical debt classification across applications" },
                { id: "application-portfolio", desc: "Application landscape by business value, quality, and cost" },
                { id: "risk-assessment-matrix", desc: "Application risk exposure by impact and likelihood" },
                { id: "lifecycle-by-category", desc: "Application lifecycle stages by department" }
            ]
        },
        {
            title: "Technology & Capability",
            charts: [
                { id: "technology-lifecycle", desc: "Technology asset lifecycle status distribution" },
                { id: "technology-stack-composition", desc: "Technology stack categories by lifecycle stage" },
                { id: "capability-maturity", desc: "Current vs target maturity levels across capabilities" },
                { id: "maturity-trend", desc: "Capability maturity gap \u2014 current state vs target" }
            ]
        }
    ];

    // =========================================================================
    // Style constants
    // =========================================================================

    // Palette: Midnight Slate
    var COLOR_BG = "#F5F7FA";
    var COLOR_SECTION_BG = "#FFFFFF";
    var COLOR_TITLE = "#2C3E50";
    var COLOR_SUBTITLE = "#7F8C8D";
    var COLOR_SECTION_HEADER = "#2980B9";
    var COLOR_DESC = "#7F8C8D";
    var COLOR_KPI_VALUE = "#27AE60";
    var COLOR_KPI_LABEL = "#95A5A6";

    // Text alignment constants: ITextAlignment — LEFT=1, CENTER=2, RIGHT=4
    var TEXT_ALIGN_CENTER = 2;

    // =========================================================================
    // Random value generators for each property
    // =========================================================================

    var RANDOM_GENERATORS = {
        "technical-debt": function () {
            var vals = ["low", "medium", "high", "critical"];
            return vals[Math.floor(Math.random() * vals.length)];
        },
        "lifecycle-status": function () {
            var vals = ["emerging", "current", "sunset", "retired"];
            return vals[Math.floor(Math.random() * vals.length)];
        },
        "business-value": function () {
            return String(Math.floor(Math.random() * 5) + 1);
        },
        "technical-quality": function () {
            return String(Math.floor(Math.random() * 5) + 1);
        },
        "annual-cost": function () {
            return String(Math.floor(Math.random() * 450) + 50);
        },
        "maturity-current": function () {
            return String(Math.floor(Math.random() * 4) + 1);
        },
        "maturity-target": function () {
            return String(Math.floor(Math.random() * 3) + 3);
        },
        "department": function () {
            var vals = ["IT", "Finance", "HR", "Operations", "Marketing"];
            return vals[Math.floor(Math.random() * vals.length)];
        },
        "risk-impact": function () {
            return String(Math.floor(Math.random() * 5) + 1);
        },
        "risk-likelihood": function () {
            return String(Math.floor(Math.random() * 5) + 1);
        },
        "technology-category": function () {
            var vals = ["Infrastructure", "Middleware", "Database", "Security", "DevOps"];
            return vals[Math.floor(Math.random() * vals.length)];
        }
    };

    // =========================================================================
    // Helpers
    // =========================================================================

    function getRawModel() {
        var models = IEditorModelManager.INSTANCE.getModels();
        if (models.size() === 1) return models.get(0);
        var modelName = model.name;
        for (var i = 0; i < models.size(); i++) {
            if (models.get(i).getName() === modelName) return models.get(i);
        }
        return models.get(0);
    }

    function setNoteImage(noteProxy, pngFilePath) {
        var rawModel = getRawModel();
        var rawNote = ArchimateModelUtils.getObjectByID(rawModel, noteProxy.id);
        if (!rawNote) throw new Error("Could not find raw EMF object for note: " + noteProxy.id);

        var archiveManager = rawModel.getAdapter(IArchiveManager.class);
        if (!archiveManager) throw new Error("Could not get IArchiveManager for model");

        var pngBytes = Files.readAllBytes(JPath.get(pngFilePath));
        var imagePath = archiveManager.addByteContentEntry(pngFilePath, pngBytes);

        rawNote.setImagePath(imagePath);
        rawNote.setImagePosition(9); // IIconic.IMAGE_POSITION_FILL
    }

    function getTempPath(noteId) {
        var tmpDir = System.getProperty("java.io.tmpdir");
        return JPath.get(tmpDir, "jarchi-chart-" + noteId + ".png").toString();
    }

    // Border constants
    var BORDER_DOGEAR = 0;
    var BORDER_RECTANGLE = 1;
    var BORDER_NONE = 2;
    var BORDER_TABBED = 0; // For Groups

    // =========================================================================
    // Sample elements for types that may not exist in the model
    // =========================================================================

    var SAMPLE_ELEMENT_NAMES = {
        "capability": [
            "Data Management", "Customer Engagement", "Financial Planning",
            "Risk Management", "Supply Chain Management", "Human Capital Management",
            "Digital Innovation", "Regulatory Compliance"
        ]
    };

    /**
     * Ensure the model has named elements of each required type.
     * Creates sample elements by name (skipping any that already exist)
     * so that charts with skipGenericNames won't end up empty.
     */
    function ensureSampleElements(templates) {
        var typesChecked = {};
        var totalCreated = 0;

        for (var t = 0; t < templates.length; t++) {
            var tmpl = templates[t];
            if (!tmpl.propertiesCreated || tmpl.propertiesCreated.length === 0) continue;

            for (var p = 0; p < tmpl.propertiesCreated.length; p++) {
                var propDef = tmpl.propertiesCreated[p];
                for (var q = 0; q < propDef.targetTypes.length; q++) {
                    var elType = propDef.targetTypes[q];
                    if (typesChecked[elType]) continue;
                    typesChecked[elType] = true;

                    if (!SAMPLE_ELEMENT_NAMES[elType]) continue;

                    // Collect existing element names to avoid duplicates
                    var existingNames = {};
                    $(elType).each(function (el) {
                        existingNames[(el.name || "").trim()] = true;
                    });

                    var names = SAMPLE_ELEMENT_NAMES[elType];
                    var created = 0;
                    for (var n = 0; n < names.length; n++) {
                        if (!existingNames[names[n]]) {
                            model.createElement(elType, names[n]);
                            created++;
                        }
                    }

                    if (created > 0) {
                        totalCreated += created;
                        log.detail("  Created " + created + " sample " + elType + " element(s)");
                    }
                }
            }
        }

        return totalCreated;
    }

    /**
     * Initialize properties with random values on matching elements.
     * Only sets values where the property doesn't already exist.
     */
    function initializeRandomProperties(templates) {
        var totalInitialized = 0;
        var processedProps = {};

        for (var t = 0; t < templates.length; t++) {
            var tmpl = templates[t];
            if (!tmpl.propertiesCreated || tmpl.propertiesCreated.length === 0) continue;

            for (var p = 0; p < tmpl.propertiesCreated.length; p++) {
                var propDef = tmpl.propertiesCreated[p];
                var propKey = propDef.name + ":" + propDef.targetTypes.join(",");

                if (processedProps[propKey]) continue;
                processedProps[propKey] = true;

                var generator = RANDOM_GENERATORS[propDef.name];
                if (!generator) continue;

                // Build target collection ($() doesn't support comma-separated types)
                var targetCollection;
                if (propDef.targetTypes.length === 1) {
                    targetCollection = $(propDef.targetTypes[0]);
                } else {
                    targetCollection = $(propDef.targetTypes[0]);
                    for (var q = 1; q < propDef.targetTypes.length; q++) {
                        targetCollection = targetCollection.add($(propDef.targetTypes[q]));
                    }
                }

                var initialized = 0;
                targetCollection.each(function (el) {
                    if (el.prop(propDef.name) === null) {
                        el.prop(propDef.name, generator());
                        initialized++;
                    }
                });

                totalInitialized += initialized;
                if (initialized > 0) {
                    log.detail("  " + propDef.name + ": set on " + initialized + " element(s)");
                }
            }
        }

        return totalInitialized;
    }

    // =========================================================================
    // Main
    // =========================================================================

    try {
        requireModel();
        log.header("Create Dashboard");

        var dashboardName = window.prompt("Dashboard view name:", "EA Dashboard");
        if (!dashboardName) {
            log.warn("Cancelled by user.");
            return;
        }

        // Build template lookup
        var allTemplates = chartDefinitions.getAllTemplates();
        var templateMap = {};
        for (var t = 0; t < allTemplates.length; t++) {
            templateMap[allTemplates[t].id] = allTemplates[t];
        }

        // Collect all templates referenced by dashboard sections
        var orderedTemplates = [];
        for (var s = 0; s < DASHBOARD_SECTIONS.length; s++) {
            var charts = DASHBOARD_SECTIONS[s].charts;
            for (var c = 0; c < charts.length; c++) {
                var tmpl = templateMap[charts[c].id];
                if (tmpl) orderedTemplates.push(tmpl);
            }
        }

        if (orderedTemplates.length === 0) {
            log.error("No chart templates found.");
            return;
        }

        log.info("Creating dashboard with " + orderedTemplates.length + " charts...");

        // --- Create sample elements for types that don't exist ---
        var samplesCreated = ensureSampleElements(orderedTemplates);
        if (samplesCreated > 0) {
            log.info("Created " + samplesCreated + " sample element(s) for missing types.");
        }

        // --- Initialize missing properties with random values ---
        log.info("Initializing missing data properties with random values...");
        var totalInit = initializeRandomProperties(orderedTemplates);
        if (totalInit > 0) {
            log.info("Initialized " + totalInit + " property value(s) across model elements.");
        } else {
            log.detail("  All properties already set (or no matching elements).");
        }

        // --- Create the dashboard view ---
        var dashView = model.createArchimateView(dashboardName);
        log.info("Created view: " + dashboardName);

        var totalGridWidth = COLS * CHART_WIDTH + (COLS - 1) * COL_GAP;

        // --- Title ---
        var titleNote = dashView.createObject("note", MARGIN_LEFT, TITLE_Y, totalGridWidth, TITLE_HEIGHT);
        titleNote.setText(dashboardName);
        titleNote.borderType = BORDER_NONE;
        titleNote.fontStyle = "bold";
        titleNote.fontSize = 28;
        titleNote.fontColor = COLOR_TITLE;
        titleNote.textAlignment = TEXT_ALIGN_CENTER;

        // --- Subtitle (model name + date) ---
        var today = new java.text.SimpleDateFormat("yyyy-MM-dd").format(new java.util.Date());
        var subtitleY = TITLE_Y + TITLE_HEIGHT;
        var subtitleNote = dashView.createObject("note", MARGIN_LEFT, subtitleY, totalGridWidth, SUBTITLE_HEIGHT);
        subtitleNote.setText("Model: " + (model.name || "unnamed") + "  \u2022  Generated: " + today);
        subtitleNote.borderType = BORDER_NONE;
        subtitleNote.fontSize = 11;
        subtitleNote.fontColor = COLOR_SUBTITLE;
        subtitleNote.textAlignment = TEXT_ALIGN_CENTER;

        var cursorY = subtitleY + SUBTITLE_HEIGHT + 30;

        // --- KPI Row ---
        // We'll add 4 simple KPI cards
        var kpiWidth = Math.floor((totalGridWidth - (3 * COL_GAP)) / 4);
        var uniquePropNames = {};
        $("element").each(function (el) {
            var keys = el.prop();
            if (keys) for (var i = 0; i < keys.length; i++) uniquePropNames[keys[i]] = true;
        });

        var kpis = [
            { label: "Total Elements", value: $("element").size() },
            { label: "Relationships", value: $("relationship").size() },
            { label: "Views", value: $("view").size() },
            { label: "Properties", value: Object.keys(uniquePropNames).length }
        ];

        for (var k = 0; k < kpis.length; k++) {
            var kpiX = MARGIN_LEFT + k * (kpiWidth + COL_GAP);
            
            // KPI Background (Group)
            var kpiGroup = dashView.createObject("group", kpiX, cursorY, kpiWidth, KPI_HEIGHT);
            kpiGroup.name = ""; // No header for the group visual
            kpiGroup.fillColor = "#FFFFFF";
            kpiGroup.borderType = BORDER_RECTANGLE;
            
            // Label
            var labelNote = kpiGroup.createObject("note", INNER_PAD, 15, kpiWidth - 2 * INNER_PAD, 30);
            labelNote.setText(kpis[k].label.toUpperCase());
            labelNote.borderType = BORDER_NONE;
            labelNote.fontColor = COLOR_KPI_LABEL;
            labelNote.fontSize = 11;
            labelNote.fontStyle = "bold";
            labelNote.textAlignment = TEXT_ALIGN_CENTER;

            // Value
            var valNote = kpiGroup.createObject("note", INNER_PAD, 45, kpiWidth - 2 * INNER_PAD, 50);
            valNote.setText(String(kpis[k].value));
            valNote.borderType = BORDER_NONE;
            valNote.fontColor = COLOR_KPI_VALUE;
            valNote.fontSize = 28;
            valNote.fontStyle = "bold";
            valNote.textAlignment = TEXT_ALIGN_CENTER;
        }

        cursorY += KPI_HEIGHT + ROW_GAP;

        // --- Place sections, descriptions, and chart notes ---
        var chartNotes = [];

        for (var s = 0; s < DASHBOARD_SECTIONS.length; s++) {
            var section = DASHBOARD_SECTIONS[s];
            
            // Calculate section height: Header + (Rows * (ChartHeight + DescHeight + Gaps)) + Padding
            // We assume 1 row per section for simplicity based on the 4-col layout and 4 charts per section
            var rows = Math.ceil(section.charts.length / COLS);
            // Height calculation update: Header + Padding + (Rows * (ChartHeight + DescGap + DescHeight + ChartGap))
            var rowHeight = CHART_HEIGHT + 60; 
            var sectionHeight = SECTION_HEADER_HEIGHT + SECTION_PADDING + 
                                rows * rowHeight + SECTION_PADDING;

            // Section Container (Group)
            var sectionGroup = dashView.createObject("group", MARGIN_LEFT, cursorY, totalGridWidth, sectionHeight);
            sectionGroup.name = "  " + section.title.toUpperCase(); // Text in group header
            sectionGroup.fontStyle = "bold";
            sectionGroup.fontSize = 14;
            sectionGroup.fontColor = COLOR_SECTION_HEADER;
            sectionGroup.fillColor = COLOR_SECTION_BG;
            sectionGroup.borderType = BORDER_RECTANGLE;
            
            // We can add objects inside the group using group.createObject
            var contentStartY = SECTION_HEADER_HEIGHT + SECTION_PADDING;

            // Calculate chart width with padding so children don't cover group borders
            var chartAreaWidth = totalGridWidth - 2 * INNER_PAD;
            var sectionChartWidth = Math.floor((chartAreaWidth - (COLS - 1) * COL_GAP) / COLS);

            for (var c = 0; c < section.charts.length; c++) {
                var chartDef = section.charts[c];
                var tmpl = templateMap[chartDef.id];
                if (!tmpl) continue;

                var col = c % COLS;
                var row = Math.floor(c / COLS);
                var chartX = INNER_PAD + col * (sectionChartWidth + COL_GAP);
                var chartY = contentStartY + row * rowHeight;

                // Chart Description
                var descNote = sectionGroup.createObject("note", chartX, chartY, sectionChartWidth, 30);
                descNote.setText(chartDef.desc);
                descNote.borderType = BORDER_NONE;
                descNote.fontSize = 10;
                descNote.fontStyle = "italic";
                descNote.fontColor = COLOR_DESC;
                descNote.textAlignment = TEXT_ALIGN_CENTER;

                // Chart Box
                var chartContentY = chartY + 30;

                var definition = chartDefinitions.createDefinition(tmpl.id, {
                    title: tmpl.chartConfig.title,
                    width: sectionChartWidth,
                    height: CHART_HEIGHT,
                    scope: "model"
                });

                // Disable in-chart title
                if (definition.chartOptions && definition.chartOptions.plugins &&
                    definition.chartOptions.plugins.title) {
                    definition.chartOptions.plugins.title.display = false;
                }

                // Allow legend to be larger if needed
                if (definition.chartOptions && definition.chartOptions.plugins &&
                    definition.chartOptions.plugins.legend) {
                     definition.chartOptions.plugins.legend.position = 'bottom';
                }

                var noteObj = sectionGroup.createObject("note", chartX, chartContentY, sectionChartWidth, CHART_HEIGHT);
                noteObj.setText(definition.title);
                noteObj.prop("chart-definition", JSON.stringify(definition));
                noteObj.borderType = BORDER_NONE; // Clean look

                chartNotes.push({ note: noteObj, definition: definition });
                log.detail("  Placed: " + definition.title);
            }
            cursorY += sectionHeight + ROW_GAP;
        }

        // --- Render all charts ---
        log.info("Rendering " + chartNotes.length + " chart(s)...");

        var rendered = 0;
        var failed = 0;

        for (var r = 0; r < chartNotes.length; r++) {
            var entry = chartNotes[r];
            var noteObj = entry.note;
            var definition = entry.definition;

            try {
                var data = chartDataCollectors.collectData(definition, dashView);

                var chartConfig = {
                    type: definition.type,
                    data: data,
                    options: definition.chartOptions || {},
                    backgroundColor: definition.backgroundColor || "#FFFFFF"
                };

                var outputPath = getTempPath(noteObj.id);
                chartSync.renderChart(chartConfig, definition.width, definition.height, outputPath);

                if (!Files.exists(JPath.get(outputPath))) {
                    throw new Error("PNG not created at: " + outputPath);
                }

                setNoteImage(noteObj, outputPath);
                noteObj.setText("");

                rendered++;
                log.detail("  Rendered: " + definition.title);
            } catch (err) {
                failed++;
                log.error("  Failed: " + definition.title + " \u2014 " + err.toString());
                if (err.stack) log.detail("    " + err.stack);
            }
        }

        // --- Open the dashboard view ---
        dashView.openInUI();

        // --- Summary ---
        var summary = "Dashboard '" + dashboardName + "' created with " +
            rendered + " chart(s) rendered";
        if (failed > 0) {
            summary += " (" + failed + " failed)";
            log.warn(summary);
        } else {
            log.success(summary);
        }

        log.success("Create Dashboard complete.");
    } catch (error) {
        log.error("Script failed: " + error.toString());
        if (error.stack) log.error(error.stack);
        window.alert("Error: " + error.message);
    }
})();
