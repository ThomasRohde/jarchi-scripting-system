/**
 * @name Build Capability Map
 * @description Finds all capabilities in the model and creates a hierarchical map view.
 * Uses an adaptive flow layout that packs children in rows, trying multiple target widths
 * and picking the best layout to minimize whitespace. All leaf capabilities have uniform
 * size based on the longest label. Subtrees are grouped before leaves for tighter packing.
 * Shows a configuration dialog for layout, sizing, colors, and depth limiting.
 * @version 2.0.0
 * @author Thomas Rohde
 * @lastModifiedDate 2026-02-23
 */

console.clear();
console.show();

load(__DIR__ + "lib/log.js");
load(__DIR__ + "lib/requireModel.js");
load(__DIR__ + "lib/swtImports.js");
load(__DIR__ + "lib/capabilityMapDialog.js");

(function () {
    "use strict";

    // =====================================================================
    // Fixed layout constants (not user-configurable)
    // =====================================================================
    var HEADER_HEIGHT = 30;
    var ROOT_GAP = 30;
    var VIEW_MARGIN = 20;
    var TARGET_ASPECT_RATIO = 1.6; // slightly wider than tall

    // =====================================================================
    // Java types for text measurement
    // =====================================================================
    var JFont = Java.type("java.awt.Font");
    var BufferedImage = Java.type("java.awt.image.BufferedImage");

    /**
     * Measure text pixel width using Java AWT FontMetrics.
     * @param {string} text
     * @returns {number} width in pixels
     */
    function measureTextWidth(text) {
        if (!text || !text.trim()) return 40;
        var img = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB);
        var g2d = img.createGraphics();
        g2d.setFont(new JFont("Segoe UI", JFont.PLAIN, 12));
        var width = g2d.getFontMetrics().stringWidth(text);
        g2d.dispose();
        return width;
    }

    /**
     * Get the display name for an element, handling null/blank names.
     * @param {Object} el - jArchi element
     * @returns {string}
     */
    function getName(el) {
        var name = el.name;
        return name && name.trim() ? name.trim() : "-- unnamed --";
    }

    // =====================================================================
    // Adaptive Flow Layout
    // =====================================================================

    /**
     * Pack children into horizontal rows given a target container width.
     * Items flow left-to-right, wrapping when the next item would exceed
     * the available content width.
     *
     * @param {Array} children - nodes with .size.w and .size.h
     * @param {number} targetWidth - total container width including padding
     * @param {Object} options - layout options with gap and padding
     * @returns {{ w: number, h: number, rows: Array }}
     */
    function packRows(children, targetWidth, options) {
        var contentWidth = targetWidth - 2 * options.padding;
        var rows = [];
        var currentRow = [];
        var currentRowWidth = 0;

        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            var needed = currentRow.length > 0 ? options.gap + child.size.w : child.size.w;

            if (currentRow.length > 0 && currentRowWidth + needed > contentWidth) {
                rows.push(currentRow);
                currentRow = [child];
                currentRowWidth = child.size.w;
            } else {
                currentRow.push(child);
                currentRowWidth += needed;
            }
        }
        if (currentRow.length > 0) rows.push(currentRow);

        // Compute per-row metrics and overall dimensions
        var maxRowWidth = 0;
        var totalHeight = HEADER_HEIGHT;
        var rowMeta = [];

        for (var r = 0; r < rows.length; r++) {
            var row = rows[r];
            var rowWidth = 0;
            var rowHeight = 0;
            for (var j = 0; j < row.length; j++) {
                if (j > 0) rowWidth += options.gap;
                rowWidth += row[j].size.w;
                if (row[j].size.h > rowHeight) rowHeight = row[j].size.h;
            }
            if (rowWidth > maxRowWidth) maxRowWidth = rowWidth;
            if (r > 0) totalHeight += options.gap;
            totalHeight += rowHeight;
            rowMeta.push({ items: row, height: rowHeight, width: rowWidth });
        }

        return {
            w: maxRowWidth + 2 * options.padding,
            h: totalHeight + options.padding,
            rows: rowMeta
        };
    }

    /**
     * Score a layout — lower is better.
     * Balances aspect ratio, wasted space, row uniformity, and last-row fill.
     */
    function scoreLayout(layout, options) {
        if (layout.rows.length === 0) return Infinity;

        // Aspect ratio: prefer close to target
        var aspect = layout.w / layout.h;
        var ratioPenalty = Math.abs(aspect - TARGET_ASPECT_RATIO);

        // Wasted space fraction
        var totalChildArea = 0;
        for (var r = 0; r < layout.rows.length; r++) {
            for (var i = 0; i < layout.rows[r].items.length; i++) {
                var s = layout.rows[r].items[i].size;
                totalChildArea += s.w * s.h;
            }
        }
        var containerArea = layout.w * layout.h;
        var wastedFraction = 1 - totalChildArea / containerArea;

        // Row width balance — penalize rows much narrower than the widest
        var maxW = layout.w - 2 * options.padding;
        var varianceSum = 0;
        for (var r2 = 0; r2 < layout.rows.length; r2++) {
            var fill = maxW > 0 ? layout.rows[r2].width / maxW : 1;
            varianceSum += (1 - fill) * (1 - fill);
        }
        var rowVariance = Math.sqrt(varianceSum / layout.rows.length);

        // Last row fill penalty
        var lastRowPenalty = 0;
        if (layout.rows.length > 1) {
            var lastW = layout.rows[layout.rows.length - 1].width;
            var firstW = layout.rows[0].width;
            if (firstW > 0) {
                lastRowPenalty = Math.max(0, 1 - lastW / firstW) * 0.5;
            }
        }

        return ratioPenalty * 3.0
             + wastedFraction * 2.0
             + rowVariance * 1.5
             + lastRowPenalty * 1.0;
    }

    /**
     * Find the best flow layout for a set of children by trying every
     * possible first-row item count and picking the lowest-scoring layout.
     *
     * @param {Array} children - nodes with computed .size
     * @param {Object} options - layout options
     * @returns {{ w: number, h: number, rows: Array }}
     */
    function computeFlowLayout(children, options) {
        if (children.length === 0) {
            return { w: 2 * options.padding, h: HEADER_HEIGHT + options.padding, rows: [] };
        }
        if (children.length === 1) {
            return {
                w: children[0].size.w + 2 * options.padding,
                h: children[0].size.h + HEADER_HEIGHT + options.padding,
                rows: [{ items: [children[0]], height: children[0].size.h, width: children[0].size.w }]
            };
        }

        var bestLayout = null;
        var bestScore = Infinity;

        // Try target widths determined by fitting k items in the first row
        for (var k = 1; k <= children.length; k++) {
            var targetW = 2 * options.padding;
            for (var i = 0; i < k; i++) {
                targetW += children[i].size.w;
                if (i > 0) targetW += options.gap;
            }

            var layout = packRows(children, targetW, options);
            var score = scoreLayout(layout, options);
            if (score < bestScore) {
                bestScore = score;
                bestLayout = layout;
            }
        }

        return bestLayout;
    }

    // =====================================================================
    // Main
    // =====================================================================

    try {
        log.header("Build Capability Map");
        requireModel();

        // 1. Collect all capabilities
        var capabilities = $("capability");
        if (capabilities.size() === 0) {
            window.alert("No capabilities found in the current model.");
            return;
        }
        log.info("Found " + capabilities.size() + " capabilities.");

        // 2. Build element lookup
        var elementMap = {};
        capabilities.each(function (c) {
            elementMap[c.id] = c;
        });

        // 3. Build parent-child tree from composition and aggregation relationships
        var childrenMap = {};
        var parentMap = {};

        function addRelationship(rel) {
            if (rel.source.type !== "capability" || rel.target.type !== "capability") return;
            var pid = rel.source.id;
            var cid = rel.target.id;
            if (parentMap[cid]) return;
            if (!childrenMap[pid]) childrenMap[pid] = [];
            if (childrenMap[pid].indexOf(cid) === -1) {
                childrenMap[pid].push(cid);
                parentMap[cid] = pid;
            }
        }

        $("composition-relationship").each(addRelationship);
        $("aggregation-relationship").each(addRelationship);

        // Sort children alphabetically for initial ordering
        Object.keys(childrenMap).forEach(function (pid) {
            childrenMap[pid].sort(function (a, b) {
                return getName(elementMap[a]).localeCompare(getName(elementMap[b]));
            });
        });

        // 4. Find root capabilities (not composed/aggregated by another capability)
        var roots = [];
        capabilities.each(function (c) {
            if (!parentMap[c.id]) roots.push(c);
        });
        roots.sort(function (a, b) {
            return getName(a).localeCompare(getName(b));
        });

        if (roots.length === 0) {
            window.alert("No root capabilities found. All capabilities have a parent — check for circular composition relationships.");
            return;
        }
        log.info("Found " + roots.length + " root capabilities.");

        // 5. Build tree structure with cycle prevention
        var visited = {};

        function buildTree(element) {
            if (visited[element.id]) return null;
            visited[element.id] = true;

            var children = (childrenMap[element.id] || [])
                .filter(function (cid) { return elementMap[cid] && !visited[cid]; })
                .map(function (cid) { return buildTree(elementMap[cid]); })
                .filter(function (n) { return n !== null; });

            return {
                element: element,
                children: children,
                isLeaf: children.length === 0,
                size: null,
                rows: []
            };
        }

        var trees = roots.map(function (r) { return buildTree(r); })
            .filter(function (t) { return t !== null; });

        // 6. Compute maxDepth from the tree
        function computeMaxDepth(node, depth) {
            if (node.children.length === 0) return depth;
            var max = depth;
            for (var i = 0; i < node.children.length; i++) {
                var childDepth = computeMaxDepth(node.children[i], depth + 1);
                if (childDepth > max) max = childDepth;
            }
            return max;
        }

        var treeMaxDepth = 0;
        for (var t = 0; t < trees.length; t++) {
            var d = computeMaxDepth(trees[t], 0);
            if (d > treeMaxDepth) treeMaxDepth = d;
        }

        // 7. Show configuration dialog
        var options = showCapabilityMapDialog(shell, treeMaxDepth, capabilities.size());
        if (!options) {
            log.info("Cancelled by user.");
            return;
        }

        log.info("Options: maxDepth=" + (options.maxDepth === -1 ? "All" : options.maxDepth)
            + ", sort=" + options.sortMode
            + ", gap=" + options.gap + ", padding=" + options.padding);

        // 8. Calculate uniform leaf size based on maximum label width
        var maxLeafTextWidth = 0;

        function findMaxLeafWidth(node, depth) {
            // Treat as leaf if at depth limit or actually a leaf
            var isEffectiveLeaf = node.isLeaf ||
                (options.maxDepth !== -1 && depth >= options.maxDepth);

            if (isEffectiveLeaf) {
                var tw = measureTextWidth(getName(node.element));
                if (tw > maxLeafTextWidth) maxLeafTextWidth = tw;
                return;
            }
            for (var i = 0; i < node.children.length; i++) {
                findMaxLeafWidth(node.children[i], depth + 1);
            }
        }

        trees.forEach(function (tree) { findMaxLeafWidth(tree, 0); });

        var leafWidth = Math.max(options.minLeafWidth, Math.min(maxLeafTextWidth + 2 * options.padding + 10, options.maxLeafWidth));
        var leafHeight = options.leafHeight;
        log.detail("  Leaf size: " + leafWidth + " x " + leafHeight);

        // 9. Calculate node sizes bottom-up using adaptive flow layout
        function calculateSize(node, depth) {
            // Treat as leaf if at depth limit or actually a leaf
            var isEffectiveLeaf = node.isLeaf ||
                (options.maxDepth !== -1 && depth >= options.maxDepth);

            if (isEffectiveLeaf) {
                node.size = { w: leafWidth, h: leafHeight };
                node.rows = [];
                node._effectiveLeaf = true;
                return;
            }

            node._effectiveLeaf = false;

            // Compute child sizes first
            for (var i = 0; i < node.children.length; i++) {
                calculateSize(node.children[i], depth + 1);
            }

            // Sort children based on user preference
            if (options.sortMode === "subtrees") {
                // Subtrees first (alphabetical), then leaves (alphabetical)
                node.children.sort(function (a, b) {
                    if (a._effectiveLeaf !== b._effectiveLeaf) return a._effectiveLeaf ? 1 : -1;
                    return getName(a.element).localeCompare(getName(b.element));
                });
            } else {
                // Pure alphabetical
                node.children.sort(function (a, b) {
                    return getName(a.element).localeCompare(getName(b.element));
                });
            }

            // Find optimal flow layout
            var layout = computeFlowLayout(node.children, options);
            node.size = { w: layout.w, h: layout.h };
            node.rows = layout.rows;
        }

        trees.forEach(function (tree) { calculateSize(tree, 0); });

        // 10. Create the view
        var view = model.createArchimateView(options.viewName);
        log.info("Created view: " + options.viewName);

        // 11. Layout and add elements to the view
        function addNode(node, parentObj, relX, relY, depth) {
            var diagObj;
            if (parentObj) {
                diagObj = view.add(node.element, 0, 0, node.size.w, node.size.h);
                parentObj.add(diagObj, relX, relY);
            } else {
                diagObj = view.add(node.element, relX, relY, node.size.w, node.size.h);
            }

            // Color by depth: effective leaves get leaf color, others get depth-based color
            if (node._effectiveLeaf) {
                diagObj.fillColor = options.leafColor;
            } else {
                var colorIdx = Math.min(depth, options.depthColors.length - 1);
                diagObj.fillColor = options.depthColors[colorIdx];
            }

            // Show icon setting
            diagObj.showIcon = options.showIcon;

            // Center text on leaves; top-align on parents so label doesn't overlap children
            diagObj.textAlignment = 2; // CENTER
            if (!node._effectiveLeaf) {
                try { diagObj.textPosition = 0; } catch (e) { /* property may not exist */ }
            } else {
                try { diagObj.textPosition = 1; } catch (e) { /* property may not exist */ }
            }

            // Position children row by row
            if (!node._effectiveLeaf) {
                var y = HEADER_HEIGHT;
                for (var r = 0; r < node.rows.length; r++) {
                    var row = node.rows[r];
                    var x = options.padding;
                    for (var i = 0; i < row.items.length; i++) {
                        var child = row.items[i];
                        // Center child vertically within its row
                        var cy = y + Math.floor((row.height - child.size.h) / 2);
                        addNode(child, diagObj, x, cy, depth + 1);
                        x += child.size.w + options.gap;
                    }
                    y += row.height + options.gap;
                }
            }

            return diagObj;
        }

        // Arrange root trees horizontally
        var cursorX = VIEW_MARGIN;
        trees.forEach(function (tree) {
            addNode(tree, null, cursorX, VIEW_MARGIN, 0);
            cursorX += tree.size.w + ROOT_GAP;
        });

        // 12. Open the view
        view.openInUI();

        log.success("Build Capability Map complete. " + capabilities.size() + " capabilities in " + roots.length + " root trees.");
    } catch (error) {
        log.error("Script failed: " + error.toString());
        if (error.stack) log.error(error.stack);
        window.alert("Error: " + error.message);
    }
})();
